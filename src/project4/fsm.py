"""Finite State Machine (FSM) abstraction.

The finite state machine (FSM) is abstracted by the `FiniteStateMachine` class.
The function `run_fsm(fsm, input_string)` runs the indicated `fsm` until it
is "done" and then checks if it accepts or rejects to return the resulting characters
read and token.

TL;DR returning `True` from a State when given an input means that the FSM is
done and it is safe to check if the resulting state is an accept or reject state
to determine if it reads a prefix of the input.

An FSM normally reads until there are no more characters left in the input
and then it checks what state it is in to determine whether it accepts or rejects.
In our application to lexical analysis we want the FSM to stop reading as soon as it
determines it is done reading and knows if it will accept or reject. As such, the
end of input is marked when the FSM signals it is "done" by returning `True` when
computing the next state. At that point, it is safe to check if the FSM is in an
accept or reject state to know whether or not it reads a prefix of the input and
how many characters are in that prefix that it can read.
"""

from io import StringIO
from typing import Callable

from project4.token import Token

State = Callable[[str], tuple[bool, "State"]]
"""
`State` is a function that takes the character to read as a `str` and returns
a `bool` signifying whether or not it is done reading and the next `State`
(`State` : `I` -> `bool` times `State`).
"""


def run_fsm(fsm: "FiniteStateMachine", input_string: str) -> tuple[int, Token]:
    """Run an FSM and return the number of characters read with the token.

    Run the FSM until it accepts or rejects while counting the number of
    characters read until the FSM is done. Once the FSM is done, check to see
    if it accepts or rejects the input. The return value is a tuple of the total
    number of characters read and the resulting token if the FSM accepts.
    A reject always reads no characters.

    Args:

        fsm: the FSM to run
        input_string: the string to use as input

    Returns:

        (output_num_chars_read, token): the number of characters read from the input and the associated token produced by the FSM as a tuple

    Examples:

        >>> from project3.fsm import run_fsm, Colon
        >>> colon = Colon()
        >>> input_string = ": a"
        >>> number_chars_read, token = run_fsm(colon, input_string)
        >>> "number_chars_read = {} token = {}".format(number_chars_read, str(token))
        'number_chars_read = 1 token = (COLON,":",0)'
    """
    stream: StringIO = StringIO(input_string)
    done, state = fsm.initial_state(stream.read(1))
    num_chars_read: int = 0

    while not done:
        num_chars_read = num_chars_read + 1
        done, state = state(stream.read(1))

    if FiniteStateMachine.is_reject(state):
        num_chars_read = 0
    elif FiniteStateMachine.is_accept(state):
        pass
    else:
        raise AssertionError(f"ERROR: unexpected {state!r}")

    value = input_string[:num_chars_read]
    return num_chars_read, fsm.token(value)


class FiniteStateMachine:
    """Base class for the finite state machine (FSM) abstraction.

    The base class defines how to detect accept and reject states
    based on the name of the functions defining the states.
    It also provides an "always done and accept" state along with
    an "always done and reject" state.

    Note: The `token` function should be overridden in each subclass.

    Attributes:
        initial_state (State): The initial state for this FSM.
    """

    def __init__(self, initial_state: State) -> None:
        """Initialize the FSM with its initial state

        Args:
            initial_state: The initial state for this FSM.
        """
        self.initial_state = initial_state

    def token(self, value: str) -> Token:
        """Return the token produced by this FSM

        NOTE: this method must be overridden in every subclass. as
        the base class always returns Token.UNDEFINED

        Args:
            value: The value associated with this `Token`.

        Returns:
            token: The token generated by the FSM when it accepts.
        """
        return Token.undefined(value)

    @staticmethod
    def is_accept(state: State) -> bool:
        """Return true if and only if `state` is an accept state

        Any `State` with `accept` in its name is an accept state.

        Args:
            state: The state being considered.

        Return:
            True if and only if `state` has accept in its name.
        """
        return "accept" in state.__name__

    @staticmethod
    def is_reject(state: State) -> bool:
        """Return true if and only if `state` is not an accept state

        Any `State` that is not an accept state.

        Args:
            state: The state being considered.

        Return:
            True if and only if `state` is not an accept state
        """
        return not FiniteStateMachine.is_accept(state)

    @staticmethod
    def s_is_done_accept(input_char: str) -> tuple[bool, State]:
        """Always done and always accept regardless of `input_char`"""
        return True, FiniteStateMachine.s_is_done_accept

    @staticmethod
    def s_is_done_reject(input_char: str) -> tuple[bool, State]:
        """Always done and always reject regardless of `input_char`"""
        return True, FiniteStateMachine.s_is_done_reject


class Colon(FiniteStateMachine):
    def __init__(self) -> None:
        super().__init__(Colon.s_0)

    def token(self, value: str) -> Token:
        """Create a token of type COLON.

        Args:
            value: The characters read by the FSM.

        Returns:
            Token.COLON: iff what is read is a ":" otherwise Token.UNDEFINED.
        """
        match value:
            case ":":
                return Token.colon(value)
            case _:
                return super().token(value)

    @staticmethod
    def s_0(input_char: str) -> tuple[bool, State]:
        if input_char == ":":
            return False, FiniteStateMachine.s_is_done_accept
        else:
            return True, FiniteStateMachine.s_is_done_reject


class Eof(FiniteStateMachine):
    def __init__(self) -> None:
        super().__init__(Eof.s_0)

    def token(self, value: str) -> Token:
        """Create a token of type EOF.

        Args:
            value: The characters read by the FSM.

        Returns:
            Token.EOF: iff what is read is an empty string otherwise Token.UNDEFINED.
        """
        match value:
            case "":
                return Token.eof(value)
            case _:
                return super().token(value)

    @staticmethod
    def s_0(input_char: str) -> tuple[bool, State]:
        if input_char == "":
            return False, FiniteStateMachine.s_is_done_accept
        else:
            return True, FiniteStateMachine.s_is_done_reject


class WhiteSpace(FiniteStateMachine):
    def __init__(self) -> None:
        super().__init__(WhiteSpace.s_0)

    def token(self, value: str) -> Token:
        """Create a token of type WHITESPACE.

        Args:
            value: The characters read by the FSM.

        Returns:
            Token.WHITESPACE: iff what is read is whitespace otherwise Token.UNDEFINED.
        """
        if value.isspace():
            return Token.whitespace(value)
        return super().token(value)

    @staticmethod
    def s_0(input_char: str) -> tuple[bool, State]:
        if input_char in [" ", "\t", "\r", "\n"]:
            return False, WhiteSpace.s_accept
        else:
            return True, FiniteStateMachine.s_is_done_reject

    @staticmethod
    def s_accept(input_char: str) -> tuple[bool, State]:
        if input_char in [" ", "\t", "\r", "\n"]:
            return False, WhiteSpace.s_accept
        else:
            return True, FiniteStateMachine.s_is_done_accept

# Datalog Rule Interpreter

Project 4 is to write an interpreter that uses relational database operations to evaluate the rules in a Datalog Program. At the end of this project, you will have a fully functional Datalog interpreter.

Here is an example input to the interpreter.

```
Schemes:
  snap(S,N,A,P)
  csg(C,S,G)
  cn(C,N)
  ncg(N,C,G)

Facts:
  snap('12345','C. Brown','12 Apple St.','555-1234').
  snap('22222','P. Patty','56 Grape Blvd','555-9999').
  snap('33333','Snoopy','12 Apple St.','555-1234').
  csg('CS101','12345','A').
  csg('CS101','22222','B').
  csg('CS101','33333','C').
  csg('EE200','12345','B+').
  csg('EE200','22222','B').

Rules:
  cn(c,n) :- snap(S,n,A,P),csg(c,S,G).
  ncg(n,c,g) :- snap(S,n,A,P),csg(c,S,g).

Queries:
  cn('CS101',Name)?
  ncg('Snoopy',Course,Grade)?
```

Your code must interpret the full program, including the rules using relational algebra, to update the relations with new facts and then answer each of the queries resulting in the following output.

```
Rule Evaluation
cn(c,n) :- snap(S,n,A,P),csg(c,S,G).
  C='CS101', N='C. Brown'
  C='CS101', N='P. Patty'
  C='CS101', N='Snoopy'
  C='EE200', N='C. Brown'
  C='EE200', N='P. Patty'
ncg(n,c,g) :- snap(S,n,A,P),csg(c,S,g).
  N='C. Brown', C='CS101', G='A'
  N='C. Brown', C='EE200', G='B+'
  N='P. Patty', C='CS101', G='B'
  N='P. Patty', C='EE200', G='B'
  N='Snoopy', C='CS101', G='C'
cn(c,n) :- snap(S,n,A,P),csg(c,S,G).
ncg(n,c,g) :- snap(S,n,A,P),csg(c,S,g).

Schemes populated after 2 passes through the Rules.

Query Evaluation
cn('CS101',Name)? Yes(3)
  Name='C. Brown'
  Name='P. Patty'
  Name='Snoopy'
ncg('Snoopy',Course,Grade)? Yes(1)
  Course='CS101', Grade='C'
```

The major steps or each described in their own file:
* [JOIN_ALGORITHM.md](./JOIN_ALGORITHM.md)
* [EVALUATE_RULE_ALGORITHM.md](./EVALUATE_RULE_ALGORITHM.md)
* [FIX_POINT_ALGORITHM.md](./FIX_POINT_ALGORITHM.md)

## Assumptions

You may assume the following about the Datalog input:

1. The Datalog program is semantically correct and satisfies all def-use requirements.
1. The head of every rule will only contain variable names. No strings will be given in the head of any rule.
1. No two variable names in a rule head are the same. Each variable in a rule head is unique in that rule head.
1. Every variable name in the head of a rule will appear in at least one predicate in the body (right-hand side) of the rule.

## FAQ

1. **When should a rule update the associated relation?**

    When a rule is evaluated, any tuples generated by the rule should be added to the associated relation immediately.

    For example, suppose there are two rules, $R1$ and $R2$, associated with relation $A$. Suppose $R1$ is evaluated first then followed by $R2$. When $R1$ is evaluated, any new tuples it generates are added to $A$. Then $R2$ is evaluated using the updated relation $A$ that contains new tuples from $R1$, and any new tuples $R2$ generates are added to $A$.

2. **When should the algorithm that repeatedly evaluates rules terminate?**

    The algorithm should evaluate the rules, repeatedly, until the number of tuples in all the relations in the database does not change. At this point, the rules do not generate any new tuples.

3. **What order should be followed in evaluating rules?**

    Evaluate the rules in the order they are given in the input file.

4. **Why is the code taking a long time to run?**

    Are you running your code in Visual Studio? Visual Studio usually runs code in 'debug' mode. Debug mode may slow down the code significantly. Try running the code outside of Visual Studio (from the command line), or configure Visual Studio to run in [release mode](https://docs.microsoft.com/en-us/visualstudio/debugger/how-to-set-debug-and-release-configurations).

    Other things that may impact running time include:

    1. The computer on which the code is running. (Run the code on the lab computers for the best approximation of how it will run on the TA computers.)
    1. Using a list to store the tuples in a relation instead of a set. (Sorting lists and searching lists for duplicates are relatively slow operations).
